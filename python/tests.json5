{
  // Python tests with pytest
  rules: [
    {
      // The `test/` folder must be named `tests/`
      files: { not: { "test/": "Rename the test/ folder to tests/" } },
    },
    {
      files: ["pyproject.toml"],
      JMESPathsMatch: [
        // Tests dependencies group must exist
        ["contains(keys(@), 'tool')", true],
        ["contains(keys(tool), 'hatch')", true],
        ["contains(keys(tool.hatch), 'envs')", true],
        ["contains(keys(tool.hatch.envs), 'tests')", true],
        // Tests environment should not be named 'test' nor 'testing'
        ["contains(keys(tool.hatch.envs), 'test')", false],
        ["contains(keys(tool.hatch.envs), 'testing')", false],
        ["type(tool.hatch.envs.tests.dependencies)", "array"],

        // pytest must be a testing dependency
        [
          "regex_match('pytest~=\\d+\\.\\d+$', tool.hatch.envs.tests.dependencies[0])",
          true,
        ],

        /**
         * Since we are testing, we should be coveraging the code, so
         * the coverage tool must be present
         **/
        ["contains(keys(tool), 'coverage')", true],
        ["contains(keys(tool.coverage), 'report')", true],
        /**
         * Always include the `tool.coverage.report` object with
         * a string "pragma: no cover" as the first argument of
         * `exclude_lines` configuration. The rationale behind this
         * is that when using the `exclude_lines` option in a
         * configuration file, we are taking control of the entire
         * list of regexes for lines to be excluded, see
         * https://coverage.rtfd.io/en/latest/excluding.html#advanced-exclusion
         *
         * Ignore also other common patters as `__repr__` and so on...
         **/
        [
          "op(tool.coverage.report.exclude_lines, '>=', ['pragma: no cover', 'def __repr__\\(', 'raise NotImplementedError', '@(abc\\.)?abstractmethod'])",
          true,
        ],
      ],
    },
    {
      /**
       * If there are scripts in `project.scripts`, it means that the package
       * has a CLI, so exclude `if __name__ == '__main__':` branches from coverage
       * reports.
       **/
      files: ["pyproject.toml"],
      ifJMESPathsMatch: {
        "pyproject.toml": [
          ["op(length(keys(project.scripts)), '>', `0`)", true],
        ],
      },
      JMESPathsMatch: [
        [
          "contains(tool.coverage.report.exclude_lines, 'if __name__ == [\"\\']__main__[\"\\']:')",
          true,
        ],
      ],
    },
    {
      /**
       * If mypy type checking is configured, exclude classes inherited
       * from Protocol from coverage reports.
       **/
      files: ["pyproject.toml"],
      ifJMESPathsMatch: {
        "pyproject.toml": [["contains(keys(tool), 'mypy')", true]],
      },
      JMESPathsMatch: [
        [
          "contains(tool.coverage.report.exclude_lines, 'class .*\\bProtocol\\):')",
          true,
        ],
      ],
    },
  ],
}
