{
  // Python tests with pytest
  rules: [
    {
      // The `test/` folder must be named `tests/`
      files: { not: { "test/": "Rename the test/ folder to tests/" } },
    },
    {
      files: ["tests/"],
      hint: "The directory for tests must exist at 'tests/'",
    },
    {
      files: ["pyproject.toml"],
      JMESPathsMatch: [
        // Tests dependencies group must exist
        ["contains(keys(@), 'tool')", true],
        ["contains(keys(tool), 'hatch')", true],
        ["contains(keys(tool.hatch), 'envs')", true],
        ["contains(keys(tool.hatch.envs), 'tests')", true],
        // Tests environment should not be named 'test' nor 'testing'
        ["contains(keys(tool.hatch.envs), 'test')", false],
        ["contains(keys(tool.hatch.envs), 'testing')", false],
        ["type(tool.hatch.envs.tests.dependencies)", "array"],

        // pytest must be a testing dependency
        [
          "regex_match('pytest~=\\d+\\.\\d+$', tool.hatch.envs.tests.dependencies[0])",
          true,
        ],

        /**
         * The commands for testing must be defined in 'tool.hatch.envs.tests.scripts'.
         **/
        ["type(tool.hatch.envs.tests.scripts)", "object"],
      ],
    },
    {
      /**
       * If there are scripts in `project.scripts`, it means that the package
       * has a CLI, so exclude `if __name__ == '__main__':` branches from coverage
       * reports.
       **/
      files: ["pyproject.toml"],
      ifJMESPathsMatch: {
        "pyproject.toml": [
          ["op(length(keys(project.scripts || `{}`)), '>', `0`)", true],
        ],
      },
      JMESPathsMatch: [
        [
          "contains(tool.coverage.report.exclude_lines, 'if __name__ == [\"\\']__main__[\"\\']:')",
          true,
        ],
      ],
    },
    {
      /**
       * If mypy type checking is configured, exclude classes inherited
       * from Protocol from coverage reports.
       **/
      files: ["pyproject.toml"],
      ifJMESPathsMatch: {
        "pyproject.toml": [["contains(keys(tool), 'mypy')", true]],
      },
      JMESPathsMatch: [
        [
          "contains(tool.coverage.report.exclude_lines, 'class .*\\bProtocol\\):')",
          true,
        ],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: 'All values in tool.hatch.envs.tests.matrix[*].python must start with "py".',
      JMESPathsMatch: [
        [
          "op(length(tool.hatch.envs.tests.matrix[*].python[] || `[]` | [?starts_with(@, 'py')]), '==', length(tool.hatch.envs.tests.matrix[*].python[] || `[]`))",
          true,
        ],
      ],
    },
    {
      /**
       * Code coverage configuration
       **/
      files: ["pyproject.toml"],
      JMESPathsMatch: [
        /**
         * Since we are testing, we should be coveraging the code, so
         * the coverage tool must be present
         **/
        ["type(tool.coverage)", "object"],
        ["type(tool.coverage.report)", "object"],

        /**
         * Always include the `tool.coverage.report` object with
         * a string "pragma: no cover" as the first argument of
         * `exclude_lines` configuration. The rationale behind this
         * is that when using the `exclude_lines` option in a
         * configuration file, we are taking control of the entire
         * list of regexes for lines to be excluded, see
         * https://coverage.rtfd.io/en/latest/excluding.html#advanced-exclusion
         *
         * Ignore also other common patters as `__repr__` and so on...
         **/
        ["type(tool.coverage.report.exclude_lines)", "array"],
        ["tool.coverage.report.exclude_lines[0]", "pragma: no cover"],
        [
          "op(tool.coverage.report.exclude_lines, '>=', ['pragma: no cover', 'def __repr__\\(', 'raise NotImplementedError', '@(abc\\.)?abstractmethod'])",
          true,
        ],

        ["type(tool.coverage.run)", "object"],
        ["type(tool.coverage.run.source)", "array"],
        ["tool.coverage.run.source[0]", "src"],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: "tool.coverage.report.omit must be an array",
      ifJMESPathsMatch: {
        "pyproject.toml": [
          ["op(tool.coverage.report.omit, '!=', `null`)", true],
        ],
      },
      JMESPathsMatch: [
        ["type(tool.coverage.report.omit)", "array"],
        ["op(length(tool.coverage.report.omit), '>', `0`)", true],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: "tool.coverage.run.omit must be an array",
      ifJMESPathsMatch: {
        "pyproject.toml": [["op(tool.coverage.run.omit, '!=', `null`)", true]],
      },
      JMESPathsMatch: [
        ["type(tool.coverage.run.omit)", "array"],
        ["op(length(tool.coverage.run.omit), '>', `0`)", true],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: "Minimum and maximum versions supported by the package (project.requires-python) must be added to the first and latest indexes to tool.hatch.envs.tests.matrix[*].python array",
      JMESPathsMatch: [
        [
          "op(tool.hatch.envs.tests.matrix[0].python[0], '==', op('py', '+', replace(regex_search('^>=(\\d+\\.\\d+)', project.\"requires-python\")[0], '.', '')))",
          true,
        ],
        [
          "op(tool.hatch.envs.tests.matrix[0].python[-1], '==', op('py', '+', replace(regex_search(',<=(\\d+\\.\\d+)$', project.\"requires-python\")[0], '.', '')))",
          true,
        ],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: "Use coverage.py for code coverage reports as the second dependency in tool.hatch.envs.tests.dependencies",
      JMESPathsMatch: [
        [
          "regex_match('coverage~=\\d+\\.\\d+$', tool.hatch.envs.tests.dependencies[1])",
          true,
        ],
      ],
    },

    /**
     * all script
     **/
    {
      files: ["pyproject.toml"],
      hint: 'The script "e2e" of tool.hatch.envs.tests.scripts must be renamed to "all"',
      JMESPathsMatch: [
        ["contains(keys(tool.hatch.envs.tests.scripts), 'e2e')", false],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: 'The script "all" must exist in tool.hatch.envs.tests.scripts',
      JMESPathsMatch: [
        ["contains(keys(tool.hatch.envs.tests.scripts), 'all')", true],
      ],
    },
    {
      files: ["pyproject.toml"],
      hint: "The script \"all\" must end with 'coverage run -m pytest'",
      JMESPathsMatch: [
        [
          "ends_with(tool.hatch.envs.tests.scripts.all || `''`, 'coverage run -m pytest')",
          true,
        ],
      ],
    },

    /**
     * unit script
     **/
    {
      files: ["tests/test_unit/"],
      hint: "The directory for unit tests 'tests/test_unit/' must exist",
    },
    {
      files: ["pyproject.toml"],
      hint: "The script \"unit\" must execute the command 'coverage run -m pytest tests/test_unit'",
      JMESPathsMatch: [
        [
          "tool.hatch.envs.tests.scripts.unit",
          "coverage run -m pytest tests/test_unit",
        ],
      ],
    },

    /**
     * integration script
     **/
    {
      files: ["pyproject.toml"],
      hint: "As the directory 'tests/test_integration/' exists, the script \"integration\" must be defined in pyproject.toml:tool.hatch.envs.tests.scripts",
      ifFilesExist: ["tests/test_integration/"],
      JMESPathsMatch: [
        ["type(tool.hatch.envs.tests.scripts.integration)", "string"],
      ],
    },
    {
      files: ["pyproject.toml"],
      ifJMESPathsMatch: {
        "pyproject.toml": [
          ["type(tool.hatch.envs.tests.scripts.integration)", "string"],
        ],
      },
      JMESPathsMatch: [
        [
          "contains(tool.hatch.envs.tests.scripts.integration, 'pytest tests/test_integration')",
          true,
        ],
      ],
    },
    {
      /**
       * cov script
       **/
      files: ["pyproject.toml"],
      JMESPathsMatch: [
        ["type(tool.hatch.envs.tests.scripts.cov)", "array"],
        ["length(tool.hatch.envs.tests.scripts.cov)", 4],
        [
          "regex_match('^hatch run \\+py=py\\d+ tests:all$', tool.hatch.envs.tests.scripts.cov[0] || `''`)",
          true,
        ],
        ["tool.hatch.envs.tests.scripts.cov[1]", "coverage html"],
        [
          "tool.hatch.envs.tests.scripts.cov[2]",
          "python -c 'import webbrowser as w;w.open(\"http://127.0.0.1:8088\")'",
        ],
        [
          "tool.hatch.envs.tests.scripts.cov[3]",
          "python -m http.server 8088 -b localhost -d htmlcov",
        ],
      ],
    },
  ],
}
